import { Octokit } from "@octokit/rest";
import type { TrackingState, CompanionPr } from "./types";
import { COMMENT_MARKER, GITHUB_PAGE_SIZE } from "./constants";

/** Create or update the tracking comment on the source PR. */
export async function updateTrackingComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  prNumber: number,
  state: TrackingState,
  sourceRepo: string,
  docsRepo: string,
): Promise<void> {
  const body = buildCommentBody(state, sourceRepo, docsRepo);
  const existingCommentId = await findTrackingComment(octokit, owner, repo, prNumber);

  if (existingCommentId) {
    await octokit.issues.updateComment({
      owner,
      repo,
      comment_id: existingCommentId,
      body,
    });
  } else {
    await octokit.issues.createComment({
      owner,
      repo,
      issue_number: prNumber,
      body,
    });
  }
}

/** Find the existing tracking comment by marker (only from the bot user). */
async function findTrackingComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  prNumber: number,
): Promise<number | null> {
  for await (const response of octokit.paginate.iterator(octokit.issues.listComments, {
    owner,
    repo,
    issue_number: prNumber,
    per_page: GITHUB_PAGE_SIZE,
  })) {
    for (const comment of response.data) {
      if (
        comment.body?.includes(COMMENT_MARKER) &&
        comment.user?.login === "github-actions[bot]"
      ) {
        return comment.id;
      }
    }
  }
  return null;
}

function buildCommentBody(
  state: TrackingState,
  sourceRepo: string,
  docsRepo: string,
): string {
  const lines = [
    COMMENT_MARKER,
    `## Documentation Impact Analysis`,
    ``,
    `**Last updated**: ${state.lastUpdated}`,
    ``,
  ];

  if (state.analysisResult.noImpact) {
    lines.push(`### No documentation impact detected`);
    lines.push(``);
    lines.push(state.analysisResult.summary);
  } else {
    lines.push(`### Summary`);
    lines.push(state.analysisResult.summary);
    lines.push(``);

    if (state.inRepoPr) {
      lines.push(`### In-repo documentation (${sourceRepo})`);
      lines.push(formatCompanionPrStatus(state.inRepoPr));
      lines.push(``);
    }

    if (state.externalPr) {
      lines.push(`### External documentation (${docsRepo})`);
      lines.push(formatCompanionPrStatus(state.externalPr));
      lines.push(``);
    }

    if (state.analysisResult.impacts.length > 0) {
      lines.push(`### Impacted Documents`);
      lines.push(``);
      lines.push(`| Action | Document | Priority | Reason |`);
      lines.push(`|--------|----------|----------|--------|`);
      for (const impact of state.analysisResult.impacts) {
        lines.push(
          `| ${escapeTableCell(impact.action)} | \`${escapeTableCell(impact.doc.path)}\` (${escapeTableCell(impact.doc.repo)}) | ${escapeTableCell(impact.priority)} | ${escapeTableCell(impact.reason)} |`,
        );
      }
    }
  }

  lines.push(``);
  lines.push(`---`);
  lines.push(`_Generated by [doc-monitor](.github/actions/doc-monitor) workflow_`);

  return lines.join("\n");
}

/** Escape markdown/HTML injection vectors in table cell values. */
function escapeTableCell(value: string): string {
  return value
    .replace(/<[^>]*>/g, "")           // strip HTML tags
    .replace(/\[([^\]]*)\]\([^)]*\)/g, "$1") // convert markdown links to plain text
    .replace(/!\[([^\]]*)\]\([^)]*\)/g, "")  // remove markdown images
    .replace(/`/g, "")                // strip backticks (prevent code span injection)
    .replace(/\|/g, "\\|")            // escape pipe (table syntax)
    .replace(/\r/g, "")               // strip carriage returns
    .replace(/\n/g, " ");             // collapse newlines
}

function formatCompanionPrStatus(pr: CompanionPr): string {
  switch (pr.status) {
    case "created":
      return `- **New PR created**: [#${pr.number}](${pr.htmlUrl}) on branch \`${pr.branch}\``;
    case "updated":
      return `- **PR updated**: [#${pr.number}](${pr.htmlUrl}) on branch \`${pr.branch}\``;
    case "existing":
      return `- **Existing PR**: [#${pr.number}](${pr.htmlUrl}) on branch \`${pr.branch}\``;
    case "conflict":
      return `- **Conflict detected**: Branch \`${pr.branch}\` has conflicts that need manual resolution.`;
    case "error":
      return `- **Error**: Could not create/update PR.`;
    default:
      return `- PR: [#${pr.number}](${pr.htmlUrl})`;
  }
}
