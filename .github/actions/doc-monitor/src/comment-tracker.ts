import { Octokit } from "@octokit/rest";
import type { TrackingState, CompanionPr } from "./types";
import { COMMENT_MARKER, GITHUB_PAGE_SIZE } from "./constants";

/** Create or update the tracking comment on the source PR. */
export async function updateTrackingComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  prNumber: number,
  state: TrackingState,
): Promise<void> {
  const body = buildCommentBody(state);
  const existingCommentId = await findTrackingComment(octokit, owner, repo, prNumber);

  if (existingCommentId) {
    await octokit.issues.updateComment({
      owner,
      repo,
      comment_id: existingCommentId,
      body,
    });
  } else {
    await octokit.issues.createComment({
      owner,
      repo,
      issue_number: prNumber,
      body,
    });
  }
}

/** Find the existing tracking comment by marker. */
async function findTrackingComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  prNumber: number,
): Promise<number | null> {
  for await (const response of octokit.paginate.iterator(octokit.issues.listComments, {
    owner,
    repo,
    issue_number: prNumber,
    per_page: GITHUB_PAGE_SIZE,
  })) {
    for (const comment of response.data) {
      if (comment.body?.includes(COMMENT_MARKER)) {
        return comment.id;
      }
    }
  }
  return null;
}

function buildCommentBody(state: TrackingState): string {
  const lines = [
    COMMENT_MARKER,
    `## Documentation Impact Analysis`,
    ``,
    `**Last updated**: ${state.lastUpdated}`,
    ``,
  ];

  if (state.analysisResult.noImpact) {
    lines.push(`### No documentation impact detected`);
    lines.push(``);
    lines.push(state.analysisResult.summary);
  } else {
    lines.push(`### Summary`);
    lines.push(state.analysisResult.summary);
    lines.push(``);

    if (state.inRepoPr) {
      lines.push(`### In-repo documentation (Azure/azure-dev)`);
      lines.push(formatCompanionPrStatus(state.inRepoPr));
      lines.push(``);
    }

    if (state.externalPr) {
      lines.push(`### External documentation (MicrosoftDocs/azure-dev-docs-pr)`);
      lines.push(formatCompanionPrStatus(state.externalPr));
      lines.push(``);
    }

    if (state.analysisResult.impacts.length > 0) {
      lines.push(`### Impacted Documents`);
      lines.push(``);
      lines.push(`| Action | Document | Priority | Reason |`);
      lines.push(`|--------|----------|----------|--------|`);
      for (const impact of state.analysisResult.impacts) {
        lines.push(
          `| ${impact.action} | \`${impact.doc.path}\` (${impact.doc.repo}) | ${impact.priority} | ${impact.reason} |`,
        );
      }
    }
  }

  lines.push(``);
  lines.push(`---`);
  lines.push(`_Generated by [doc-monitor](.github/actions/doc-monitor) workflow_`);

  return lines.join("\n");
}

function formatCompanionPrStatus(pr: CompanionPr): string {
  switch (pr.status) {
    case "created":
      return `- **New PR created**: [#${pr.number}](${pr.htmlUrl}) on branch \`${pr.branch}\``;
    case "updated":
      return `- **PR updated**: [#${pr.number}](${pr.htmlUrl}) on branch \`${pr.branch}\``;
    case "existing":
      return `- **Existing PR**: [#${pr.number}](${pr.htmlUrl}) on branch \`${pr.branch}\``;
    case "conflict":
      return `- **Conflict detected**: Branch \`${pr.branch}\` has conflicts that need manual resolution. ${pr.message || ""}`;
    case "error":
      return `- **Error**: Could not create/update PR. ${pr.message || ""}`;
    default:
      return `- PR: [#${pr.number}](${pr.htmlUrl})`;
  }
}
