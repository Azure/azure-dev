// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package cmd

import (
	"context"
	"fmt"
	"io"
	"strings"
	"sync"
	"sync/atomic"

	"github.com/azure/azure-dev/cli/azd/pkg/azdext"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/spf13/cobra"
)

// buildGateWriter wraps an io.Writer and monitors written content.
// For Aspire/dotnet services, it closes a channel when it detects "Deploying services (azd deploy)"
// in the output, which indicates that the AppHost and dotnet project have been successfully built
// and the manifest has been generated. At this point, it's safe for other dotnet services to start
// building in parallel.
type buildGateWriter struct {
	writer       io.Writer
	gate         *buildGate
	gateReleased *atomic.Bool
	serviceName  string
	releaseMu    sync.Mutex
}

func newBuildGateWriter(w io.Writer, gate *buildGate, gateReleased *atomic.Bool, serviceName string) *buildGateWriter {
	return &buildGateWriter{
		writer:       w,
		gate:         gate,
		gateReleased: gateReleased,
		serviceName:  serviceName,
	}
}

func (bw *buildGateWriter) Write(p []byte) (n int, err error) {
	// Always write to the underlying writer first
	n, err = bw.writer.Write(p)

	// Check if we should release the gate
	bw.releaseMu.Lock()
	defer bw.releaseMu.Unlock()

	if !bw.gateReleased.Load() {
		content := string(p)
		// Look for "Deploying services (azd deploy)" in the output
		// This indicates the Aspire manifest has been generated and the dotnet build is complete
		if strings.Contains(content, "Deploying services (azd deploy)") {
			bw.gateReleased.Store(true)
			bw.gate.Open()
		}
	}

	return n, err
}

func newUpCommand() *cobra.Command {
	return &cobra.Command{
		Use:   "up",
		Short: "Runs azd up in concurrent mode",
		RunE:  runUpCommand,
	}
}

func runUpCommand(cmd *cobra.Command, args []string) error {
	ctx := azdext.WithAccessToken(cmd.Context())

	// Create cancellable context for handling Ctrl+C in UI
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	// Initialize AZD client and get services
	services, workflowClient, cleanup, err := initializeAzdClient(ctx)
	if err != nil {
		return err
	}
	defer cleanup()

	// Create Bubble Tea UI with cancel function
	ui := createUI(services, cancel)

	// Create and run concurrent deployer
	deployer, err := NewConcurrentDeployer(ctx, workflowClient, services, ui)
	if err != nil {
		return err
	}

	err = deployer.Deploy()
	if summary := deployer.FinalSummary(); summary != "" {
		fmt.Print(summary)
	}
	return err
}

// initializeAzdClient creates an AZD client and retrieves service configuration
func initializeAzdClient(ctx context.Context) (
	map[string]*azdext.ServiceConfig,
	azdext.WorkflowServiceClient,
	func(),
	error,
) {
	azdClient, err := azdext.NewAzdClient()
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to create azd client: %w", err)
	}

	cleanup := func() { azdClient.Close() }

	// Get resolved services (includes services generated by importers like Aspire)
	projectClient := azdClient.Project()
	resolvedResp, err := projectClient.GetResolvedServices(ctx, &azdext.EmptyRequest{})
	if err != nil {
		return nil, nil, cleanup, fmt.Errorf("failed to get resolved services: %w", err)
	}

	services := resolvedResp.GetServices()
	workflowClient := azdClient.Workflow()

	return services, workflowClient, cleanup, nil
}

// createUI initializes the Bubble Tea program
func createUI(services map[string]*azdext.ServiceConfig, cancel context.CancelFunc) *tea.Program {
	serviceNames := make([]string, 0, len(services))
	for name := range services {
		serviceNames = append(serviceNames, name)
	}

	model := newDeploymentModel(serviceNames, cancel)
	return tea.NewProgram(
		model,
		tea.WithAltScreen(),       // Use alternate screen buffer
		tea.WithMouseCellMotion(), // Enable mouse support
	)
}
