// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package vsrpc

import (
	"context"
	_ "embed"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/azure/azure-dev/cli/azd/pkg/environment/azdcontext"
	"github.com/azure/azure-dev/cli/azd/pkg/exec"
	"github.com/azure/azure-dev/cli/azd/pkg/ioc"
	"github.com/azure/azure-dev/cli/azd/pkg/osutil"
	"github.com/azure/azure-dev/cli/azd/pkg/tools/dotnet"
	"github.com/azure/azure-dev/cli/azd/test/mocks/mockexec"
	"github.com/stretchr/testify/require"
)

//go:embed testdata/manifests/aspire-starter.json
var aspireStarterManifest []byte

func TestAspireServiceGetAspireHostAsync(t *testing.T) {
	t.Parallel()

	projectRoot := t.TempDir()
	err := copySample(projectRoot, "aspire-starter")
	require.NoError(t, err)

	runner := mockexec.NewMockCommandRunner()

	// Mock checking if a project is an App Host or not. If the csproj ends with `.AppHost.csproj` we'll consider it an
	// AppHost, as is the Aspire convention.
	runner.When(func(args exec.RunArgs, command string) bool {
		return args.Cmd == "dotnet" &&
			args.Args[0] == "msbuild" &&
			args.Args[2] == "--getProperty:IsAspireHost"
	}).RespondFn(func(args exec.RunArgs) (exec.RunResult, error) {
		if strings.HasSuffix(args.Args[1], ".AppHost.csproj") {
			return exec.NewRunResult(0, "true\n", ""), nil
		} else {
			return exec.NewRunResult(0, "false\n", ""), nil
		}
	})

	// Mock fetching the manifest from the app host, by returning the fixed version we generated by hand and checked in.
	runner.When(func(args exec.RunArgs, command string) bool {
		return args.Cmd == "dotnet" &&
			args.Args[0] == "run" &&
			args.Args[3] == "--publisher" &&
			args.Args[4] == "manifest" &&
			args.Args[5] == "--output-path"
	}).RespondFn(func(args exec.RunArgs) (exec.RunResult, error) {
		err := os.WriteFile(args.Args[6], aspireStarterManifest, osutil.PermissionFileOwnerOnly)
		require.NoError(t, err)
		return exec.NewRunResult(0, "", ""), nil
	})

	rootContainer := ioc.NewNestedContainer(nil)
	ioc.RegisterInstance(rootContainer, azdcontext.NewAzdContextWithDirectory(projectRoot))
	ioc.RegisterInstance(rootContainer, dotnet.NewDotNetCli(runner))

	server := NewServer(rootContainer)
	aspireSvc := newAspireService(server)

	// validateHostResult is the validation logic for the return value of GetAspireHostAsync, which is shared between
	// subtests.
	validateHostResult := func(t *testing.T, host *AspireHost) {
		require.NotNil(t, host)
		require.Equal(t, filepath.Join(projectRoot, "aspire-starter.AppHost", "aspire-starter.AppHost.csproj"), host.Path)
		require.Len(t, host.Services, 2)

		// The result is just based of information in the manifest, so we should have no endpoint or resource information and
		// every service should be marked as internal.
		for _, svc := range host.Services {
			require.False(t, svc.IsExternal)
			require.Nil(t, svc.Endpoint)
			require.Nil(t, svc.ResourceId)
		}
	}

	// First, ensure this this RPC works for a project that has not been `azd init`'d yet. Callers of this RPC will use this
	// information during flows which need to work before `azd init` has been run for the project. Since this RPC only
	// returns information gleamed from the App Host itself, this is possible.
	t.Run("Without azure.yaml", func(t *testing.T) {
		id, session, err := server.newSession()
		require.NoError(t, err)
		session.container = rootContainer

		o, _ := newLoggingObserver[ProgressMessage]()
		host, err := aspireSvc.GetAspireHostAsync(context.Background(), Session{Id: id}, "Production", o)
		require.NoError(t, err)
		validateHostResult(t, host)
	})

	// Now, drop an `azure.yaml` into the root of the test project and try again. This exercises a different path of
	// GetAspireHostAsync, but the results should be the same. We use a seperate session to ensure that we don't reuse any
	// cached data.
	projectFile := fmt.Sprintf(`name: aspire-starter
services:
  app:
    language: dotnet
    project: .%saspire-starter.AppHost%saspire-starter.AppHost.csproj
    host: containerapp
`, string(filepath.Separator), string(filepath.Separator))

	projectFilePath := filepath.Join(projectRoot, azdcontext.ProjectFileName)

	err = os.WriteFile(projectFilePath, []byte(projectFile), osutil.PermissionFile)
	require.NoError(t, err)

	t.Run("With azure.yaml", func(t *testing.T) {
		id, session, err := server.newSession()
		require.NoError(t, err)
		session.container = rootContainer

		o, _ := newLoggingObserver[ProgressMessage]()
		host, err := aspireSvc.GetAspireHostAsync(context.Background(), Session{Id: id}, "Production", o)
		require.NoError(t, err)
		validateHostResult(t, host)
	})
}
