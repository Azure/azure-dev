import { DefaultAzureCredential } from "@azure/identity";
import { setLogLevel } from "@azure/logger";
import { ResourceManagementClient } from "@azure/arm-resources";
import { ContainerAppsAPIClient, ContainerApp } from "@azure/arm-appcontainers";
import { ContainerRegistryManagementClient } from "@azure/arm-containerregistry";
import { CognitiveServicesManagementClient } from "@azure/arm-cognitiveservices";
import { OperationalInsightsManagementClient } from "@azure/arm-operationalinsights";
import { ApplicationInsightsManagementClient } from "@azure/arm-appinsights";
import * as fs from "fs";
import * as https from "https";
import { execSync } from "child_process";

setLogLevel("info");

const subscriptionId = process.env.AZURE_SUBSCRIPTION_ID!;
const environmentName = process.env.AZURE_ENV_NAME!;
const location = process.env.AZURE_LOCATION!;
const principalId = process.env.AZURE_PRINCIPAL_ID!;
const serviceName = process.env.AZURE_SERVICE_NAME || "llama-index-javascript";

const azdConfig = require('./config/azd.config.json');

async function waitForManagedEnvReady(rgName: string, envName: string, containerAppsClient: ContainerAppsAPIClient) {
  const maxRetries = 30;
  const delayMs = 5000;
  for (let i = 0; i < maxRetries; i++) {
    const envStatus = await containerAppsClient.managedEnvironments.get(rgName, envName);
    if (envStatus.provisioningState === "Succeeded" || envStatus.provisioningState === "Ready") {
      return;
    }
    console.log("Waiting for managed environment to be ready... current state: " + envStatus.provisioningState);
    await new Promise(r => setTimeout(r, delayMs));
  }
  throw new Error("Timed out waiting for managed environment to be ready");
}

async function httpsPut(url: string, token: string, body: any): Promise<void> {
  return new Promise((resolve, reject) => {
    const data = JSON.stringify(body);
    const parsedUrl = new URL(url);
    const options: https.RequestOptions = {
      hostname: parsedUrl.hostname,
      path: parsedUrl.pathname + parsedUrl.search,
      method: "PUT",
      headers: {
        "Authorization": "Bearer " + token,
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(data)
      }
    };

    const req = https.request(options, (res) => {
      let resData = "";
      res.on("data", chunk => resData += chunk);
      res.on("end", () => {
        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
          resolve();
        } else {
          reject(new Error("Request failed with status " + res.statusCode + ": " + resData));
        }
      });
    });

    req.on("error", reject);
    req.write(data);
    req.end();
  });
}

async function deployModel(deployment: string, model: string, version: string, capacity: number) {
  const aoaiName = "aoai-" + environmentName;
  const rgName = "rg-" + environmentName;
  const token = (await new DefaultAzureCredential().getToken("https://management.azure.com/.default"))?.token;
  if (!token) throw new Error("Failed to get token");

  const url = [
    "https://management.azure.com",
    "subscriptions", subscriptionId,
    "resourceGroups", rgName,
    "providers", "Microsoft.CognitiveServices",
    "accounts", aoaiName,
    "deployments", deployment
  ].join("/") + "?api-version=2023-10-01-preview";

  const body = {
    sku: { name: "Standard", capacity },
    properties: {
      model: {
        format: "OpenAI",
        name: model,
        version
      }
    }
  };

  await httpsPut(url, token, body);
}

async function main() {
  const credential = new DefaultAzureCredential();
  const resourceClient = new ResourceManagementClient(credential, subscriptionId);
  const containerAppsClient = new ContainerAppsAPIClient(credential, subscriptionId);
  const acrClient = new ContainerRegistryManagementClient(credential, subscriptionId);
  const cognitiveClient = new CognitiveServicesManagementClient(credential, subscriptionId);
  const insightsClient = new ApplicationInsightsManagementClient(credential, subscriptionId);
  const workspaceClient = new OperationalInsightsManagementClient(credential, subscriptionId);

  const tags = { "azd-env-name": environmentName };
  const rgName = "rg-" + environmentName;
  const envName = "env-" + environmentName;
  const acrName = "acr" + environmentName.replace(/-/g, "").toLowerCase();
  const appName = "app-" + environmentName;
  const aoaiName = "aoai-" + environmentName;
  const workspaceName = "log-" + environmentName;
  const appInsightsName = "appi-" + environmentName;
  const identityName = "id-" + environmentName;
  const identityId = "/subscriptions/" + subscriptionId + "/resourceGroups/" + rgName +
    "/providers/Microsoft.ManagedIdentity/userAssignedIdentities/" + identityName;

  await resourceClient.resourceGroups.createOrUpdate(rgName, {
    location,
    tags
  });

  // Managed Identity
  await resourceClient.resources.beginCreateOrUpdateByIdAndWait(identityId, "2023-01-31", {
    location,
    tags
  });

  // Log Analytics Workspace
  const workspace = await workspaceClient.workspaces.beginCreateOrUpdateAndWait(rgName, workspaceName, {
    location,
    sku: { name: "PerGB2018" },
    retentionInDays: 30
  });

  // App Insights (classic mode linked to workspace)
  await insightsClient.components.createOrUpdate(rgName, appInsightsName, {
    kind: "web",
    applicationType: "web",
    location,
    workspaceResourceId: workspace.id
  } as any);

  // Container App Environment
  const sharedKeys = await workspaceClient.sharedKeysOperations.getSharedKeys(rgName, workspaceName);
  const env = await containerAppsClient.managedEnvironments.beginCreateOrUpdateAndWait(rgName, envName, {
    location,
    tags,
    appLogsConfiguration: {
      destination: "log-analytics",
      logAnalyticsConfiguration: {
        customerId: workspace.customerId!,
        sharedKey: sharedKeys.primarySharedKey!
      }
    }
  });

  await waitForManagedEnvReady(rgName, envName, containerAppsClient);

  const acr = await acrClient.registries.beginCreateAndWait(rgName, acrName, {
    location,
    sku: { name: "Basic" },
    adminUserEnabled: true
  });

  const acrCreds = await acrClient.registries.listCredentials(rgName, acrName);
  const acrUsername = acrCreds.username;
  const acrPassword = acrCreds.passwords?.[0]?.value;
  const port = process.env.AZURE_PORT || "3000";

  if (!acrPassword) throw new Error("ACR password not available");

  const escapedPrompt = azdConfig.system_prompt.replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r');

  await containerAppsClient.containerApps.beginCreateOrUpdateAndWait(rgName, appName, {
    location,
    managedEnvironmentId: env.id,
    configuration: {
      ingress: { external: true, targetPort: 3000 },
      secrets: [
        { name: "registry-password", value: acrPassword }
      ],
      registries: [
        {
          server: acr.loginServer,
          username: acrUsername,
          passwordSecretRef: "registry-password"
        }
      ]
    },
    template: {
      containers: [{
        name: "app",
        image: "mcr.microsoft.com/azuredocs/containerapps-helloworld:latest",
        resources: { cpu: 0.5, memory: "1Gi" },
        env: [
          { name: "PORT", value: port },
          { name: "AZURE_OPENAI_API_VERSION", value: serviceName },
          { name: "MODEL_PROVIDER", value: azdConfig.model_provider },
          { name: "MODEL", value: azdConfig.chat.model },
          { name: "EMBEDDING_MODEL", value: azdConfig.embedding.model },
          { name: "EMBEDDING_DIM", value: azdConfig.embedding.dim },
          { name: "OPENAI_API_TYPE", value: azdConfig.openai_api_type || "AzureOpenAI" },
          { name: "LLM_TEMPERATURE", value: azdConfig.llm_temperature },
          { name: "LLM_MAX_TOKENS", value: azdConfig.llm_max_tokens },
          { name: "TOP_K", value: azdConfig.top_k },
          { name: "FILESERVER_URL_PREFIX", value: azdConfig.fileserver_url_prefix },
          { name: "SYSTEM_PROMPT", value: escapedPrompt },
          { name: "STORAGE_CACHE_DIR", value: "./cache" },
      ],
    },
    tags: {
      ...tags,
      "azd-service-name": serviceName
    }
  });

  await cognitiveClient.accounts.beginCreateAndWait(rgName, aoaiName, {
    location,
    kind: "OpenAI",
    sku: { name: "S0" },
    properties: {
      customSubDomainName: aoaiName,
      publicNetworkAccess: "Enabled"
    },
    tags
  });

  await deployModel(
    azdConfig.chat.deployment,
    azdConfig.chat.model,
    azdConfig.chat.version,
    azdConfig.chat.capacity
  );

  await deployModel(
    azdConfig.embedding.deployment,
    azdConfig.embedding.model,
    azdConfig.embedding.version,
    azdConfig.embedding.capacity
  );

  const outputs = {
    AZURE_CONTAINER_REGISTRY_ENDPOINT: { value: acr.loginServer },
    AZURE_CLIENT_ID: { value: principalId || "" },
    APPLICATION_INSIGHTS_CONNECTION_STRING: { value: "InstrumentationKey=" + workspace.customerId + ";IngestionEndpoint=" + workspace.customerId + "/v2/track" },
    AZURE_RESOURCE_LLAMA_INDEX_JAVASCRIPT_ID: { value: "/subscriptions/" + subscriptionId + "/resourceGroups/rg-" + environmentName + "/providers/Microsoft.App/containerApps/" + azdConfig.serviceName },
    AZURE_OPENAI_ENDPOINT: { value: "https://" + aoaiName + ".openai.azure.com" },
    AZURE_OPENAI_API_VERSION: { value: azdConfig.openai_api_version },
    MODEL_PROVIDER: { value: azdConfig.model_provider },
    MODEL: { value: azdConfig.chat.model },
    EMBEDDING_MODEL: { value: azdConfig.embedding.model },
    EMBEDDING_DIM: { value: azdConfig.embedding.dim },
    LLM_TEMPERATURE: { value: azdConfig.llm_temperature },
    LLM_MAX_TOKENS: { value: azdConfig.llm_max_tokens },
    OPENAI_API_TYPE: { value: azdConfig.openai_api_type || "AzureOpenAI" },
    TOP_K: { value: azdConfig.top_k },
    FILESERVER_URL_PREFIX: { value: azdConfig.fileserver_url_prefix },
    SYSTEM_PROMPT: { value: escapedPrompt },
    STORAGE_CACHE_DIR: { value: "./cache" },
    PORT: { value: process.env.PORT || "3000" },
  };

  fs.writeFileSync("outputs.json", JSON.stringify(outputs, null, 2));
  console.log(JSON.stringify(outputs, null, 2));

  for (const [key, val] of Object.entries(outputs)) {
    const value = val.value;
    if (value === null || value === undefined || value === "") continue;
    execSync("azd env set " + key + " \"" + value.replace(/"/g, '\\"') + "\"", { stdio: "inherit" });
  }
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});