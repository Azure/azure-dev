# Consumes the following variables from Set-TemplateTestMatrixVariable.ps1:
# - TemplateName
# - UseUpperCase
# and additional variables specified by template-test-generate-jobs.yml


steps:
- pwsh: |
    npm install -g @devcontainers/cli
  displayName: Install Devcontainer

- template: /eng/pipelines/templates/steps/install-azd-live-sh.yml
  parameters:
    Version: $(AzdVersion)

- template: /eng/pipelines/templates/steps/azd-login.yml

# Java pre-requisites that isn't met
# TODO: Use azd container as a form of validation that the container works
- template: /eng/pipelines/templates/steps/install-ms-openjdk.yml

# Required to clone repos that are not yet public
- template: /eng/pipelines/templates/steps/set-git-credentials.yml

- pwsh: |
    $templateName = '$(TemplateName)'.Substring(14)
    $useUpperCaseName = '$(UseUpperCase)'
    $envPrefixName = "azd-template-test"
    if($useUpperCaseName -eq "true") {
      # Use upper case name for env prefix name
      $envPrefixName = "AZD-TEMPLATE-UPPER-TEST"
    } 
    $resourceGroupName = "rg-$envPrefixName-$templateName-$(Build.BuildId)"
    Write-Host "Resource group name: $resourceGroupName"
    Write-Host "##vso[task.setvariable variable=ResourceGroupName]$resourceGroupName"
    Write-Host "##vso[task.setvariable variable=EnvPrefixName]$envPrefixName"

    $SynchronousCleanup = 'true'
    if ('$(Build.Reason)' -eq 'PullRequest') {
      $SynchronousCleanup = 'false'
    }
    Write-Host "##vso[task.setvariable variable=SynchronousCleanup]$SynchronousCleanup"

    $CleanupImmediate = 'true'
    if ($(CleanupHoursDelay) -ne '0') {
      $CleanupImmediate = 'false'
    }
    Write-Host "##vso[task.setvariable variable=CleanupImmediate]$CleanupImmediate"
  displayName: Set test run parameters

- pwsh: |
    git config --global user.name "azure-sdk"
    git config --global user.email "azuresdk@microsoft.com"
    echo "https://azure-sdk:$(azuresdk-github-pat)@github.com" > ~/.git-credentials
    git config --global credential.helper "store"
    echo "$templateName"
    $folderPath = '$(pwd)'
    git clone https://github.com/$(TemplateName).git/ temp
    ls
    dir
    cd temp
    ls
    dir
  displayName: Clone template repository

- task: DevcontainersCI@0
  displayName: Test templates in Devcontainer
  inputs:
    subFolder: ' /mnt/vss/_work/1/s/temp'
  # Required secrets for Terraform service principal authentication
    env: |
      ARM_CLIENT_ID=$(arm-client-id)
      ARM_CLIENT_SECRET=$(arm-client-secret)
      ARM_TENANT_ID=$(arm-tenant-id)
      SUBSCRIPTION_ID=$(SubscriptionId)
    runCmd: |
      curl -fsSL https://aka.ms/install-azd.sh | bash -s -- --version 'daily' --verbose
      echo "$PWD"
      echo "azd version"
      azd version
      azd login \
        --client-id "$(arm-client-id)" \
        --client-secret "$(arm-client-secret)" \
        --tenant-id "$(arm-tenant-id)"

      set -euo pipefail
      FOLDER_PATH="/workspaces/temp"
      BRANCH_NAME=$(TemplateBranchName)
      ENV_NAME_PREFIX=$(EnvPrefixName)
      TEMPLATE_NAME=$(TemplateName)
      PLAYWRIGHT_RETRIES="1"
      PLAYWRIGHT_REPORTER='list'
      LOCATION=$(AzureLocation)
      SUBSCRIPTION=$(SubscriptionId)
      ENV_SUFFIX=$(Build.BuildId)
      TEST_ONLY=false
      CLEANUP=$(SynchronousCleanup)

      function deployTemplate {
          echo "Creating new project folder @ '$FOLDER_PATH/$3'..."
          cd "$FOLDER_PATH"
          mkdir "$3"
          cd "$3"

          echo "Initializing template '$1' with branch '$2'"
          azd init -t "$1" -b "$2" -e "$3" --subscription "$4" --location "$5" --no-prompt

          echo "Provisioning infrastructure for $3..."
          azd provision -e "$3"

          echo "Deploying apps for $3..."
          azd deploy -e "$3"
      }

      function testTemplate {
          echo "Running template smoke tests for $3..."
          cd "$FOLDER_PATH/$3/tests"
          npm i && npx playwright install
          npx -y playwright test --retries="$PLAYWRIGHT_RETRIES" --reporter="$PLAYWRIGHT_REPORTER"
      }

      function cleanupTemplate {
          echo "Deprovisioning infrastructure for $3..."
          cd "$FOLDER_PATH/$3"
          azd down -e "$3" --force --purge

          echo "Cleaning up local project @ '$FOLDER_PATH/$3'..."
          rm -rf "$FOLDER_PATH/${3:?}"
      }

      if [[ -z $TEMPLATE_NAME ]]; then
          declare -A ENV_TEMPLATE_MAP

          echo "Getting list of available templates..."
          TEMPLATES_JSON=$(azd template list --output json)

          while read -r TEMPLATE; do
              ENV_NAME="${ENV_NAME_PREFIX}-${TEMPLATE:14}-$ENV_SUFFIX"
              ENV_TEMPLATE_MAP[$TEMPLATE]=$ENV_NAME
          done < <(echo "$TEMPLATES_JSON" | jq -r '.[].name' | sed 's/\\n/\n/g')

          if [ $TEST_ONLY == false ]; then
              # Deploy the templates in parallel
              for TEMPLATE in "${!ENV_TEMPLATE_MAP[@]}"; do
                  (deployTemplate "$TEMPLATE" "$BRANCH_NAME" "${ENV_TEMPLATE_MAP[$TEMPLATE]}" "${SUBSCRIPTION}" "${LOCATION}" || continue) &
              done

              wait
          fi

          # Test the templates serially
          for TEMPLATE in "${!ENV_TEMPLATE_MAP[@]}"; do
              testTemplate "$TEMPLATE" "$BRANCH_NAME" "${ENV_TEMPLATE_MAP[$TEMPLATE]}" || continue
          done

          if [ "$CLEANUP" == true ]; then
              # Cleanup the templates in parallel
              for TEMPLATE in "${!ENV_TEMPLATE_MAP[@]}"; do
                  (cleanupTemplate "$TEMPLATE" "$BRANCH_NAME" "${ENV_TEMPLATE_MAP[$TEMPLATE]}" || continue) &
              done

              wait
          fi

          echo ""
          echo "Done!"
      else
          # Run test for the specified template name
          ENV_NAME="${ENV_NAME_PREFIX}-${TEMPLATE_NAME:14}-$ENV_SUFFIX"
          if [ $TEST_ONLY == false ]; then
              deployTemplate "$TEMPLATE_NAME" "$BRANCH_NAME" "$ENV_NAME" "${SUBSCRIPTION}" "${LOCATION}" 
          fi

          testTemplate "$TEMPLATE_NAME" "$BRANCH_NAME" "$ENV_NAME"

          if [ "$CLEANUP" == true ]; then
              cleanupTemplate "$TEMPLATE_NAME" "$BRANCH_NAME" "$ENV_NAME"
          fi
      fi

    

- template: /eng/pipelines/templates/steps/az-login.yml

# First tag the resource group (if exists) so that it can get cleaned up
# by the cleanup pipeline. Then attempt to delete the resource group 
# directly. If the delete fails the cleanup pipeline will delete it.
- pwsh: |
    $resourceGroupId = az group show `
      --resource-group '$(ResourceGroupName)' `
      --query id

    if ($LASTEXITCODE) {
      Write-Host "Could not get information for resource group: $(ResourceGroupName)"
      exit 0
    }

    if ('$(CleanupImmediate)' -eq 'true') {
      # Tag the resource group so it gets cleaned up later if delete fails
      az tag create `
        --resource-id $resourceGroupId `
        --tags DeleteAfter="$((Get-Date -AsUTC).ToString('o'))"

      # Attempt to delete the resource group
      az group delete --resource-group $(ResourceGroupName) --yes --no-wait
    } else {
      $delayInHours = [int]'$(CleanupHoursDelay)'
      # Tag the resource group for delayed cleanup
      az tag create `
        --resource-id $resourceGroupId `
        --tags DeleteAfter="$((Get-Date -AsUTC).AddHours($delayInHours).ToString('o'))"
    }
  condition: always()
  displayName: Tag resource group for deletion
